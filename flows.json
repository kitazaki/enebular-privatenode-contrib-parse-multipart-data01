[{"id":"e083faffd5cc2f5f","type":"subflow","name":"parse-multipart-data","info":"","category":"","in":[{"x":60,"y":80,"wires":[{"id":"e9276030770ef554"}]}],"out":[{"x":340,"y":80,"wires":[{"id":"e9276030770ef554","port":0}]}],"env":[],"meta":{"module":"enebular-privatenode-contrib-parse-multipart-data01","type":"parse-multipart-data","version":"0.0.2","author":"Ayachika Kitazaki <kitazaki@gmail.com>","desc":"A node to parse multipart data not using parse-multipart-data npm module","keywords":"enebular,parse-multipart-data","license":"Apache-2.0"},"color":"#DDAA99"},{"id":"e9276030770ef554","type":"function","z":"e083faffd5cc2f5f","name":"function 3","func":"function getBoundary(header) {\n    if (typeof header === 'undefined' || header === null) {\n        return \"\";\n    }\n    var items = header.split(';');\n    if (items)\n        for (let i = 0; i < items.length; i++) {\n            var item = (new String(items[i])).trim();\n            if (item.indexOf('boundary') >= 0) {\n                var k = item.split('=');\n                return (new String(k[1])).trim();\n            }\n        }\n    return \"\";\n}\n\nfunction obj(str) {\n    if (typeof str === 'undefined' || str === null) {\n        return {};\n    }\n    var k = str.split('=');\n    if (k.length < 2) { // '='で分割した結果が2つの要素を持たない場合\n        return {}; // または適切なエラーハンドリング\n    }\n    var a = k[0].trim();\n    var b = JSON.parse(k[1].trim());\n    var o = {};\n    Object.defineProperty(o, a,\n        { value: b, writable: true, enumerable: true, configurable: true })\n    return o;\n}\n\nfunction process1(part) {\n    if (typeof part.header === 'undefined' || part.header === null) {\n        return {};\n    }\n    var header = part.header.split(';');\n    var file = obj(header.length > 2 ? header[2] : null); // header[2]が存在しない場合はnullを渡す\n    if (typeof part.info === 'undefined' || part.info === null || !part.info.includes(':')) {\n        return file; // part.infoが不正な形式の場合はfileをそのまま返す\n    }\n    var contentTypeParts = part.info.split(':');\n    if (contentTypeParts.length < 2) {\n        return file; // ':'で分割した結果が2つの要素を持たない場合\n    }\n    var file = obj(header[2]);\n    var contentType = part.info.split(':')[1].trim();\n    Object.defineProperty(file, 'type',\n        { value: contentType, writable: true, enumerable: true, configurable: true })\n    Object.defineProperty(file, 'data',\n        { value: new Buffer(part.part), writable: true, enumerable: true, configurable: true })\n    return file;\n}\n\nfunction Parse(multipartBodyBuffer, boundary) {\n    var prev = null;\n    var lastline = '';\n    var header = '';\n    var info = ''; var state = 0; var buffer = [];\n    var allParts = [];\n\n    for (let i = 0; i < multipartBodyBuffer.length; i++) {\n        var oneByte = multipartBodyBuffer[i];\n        var prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n        var newLineDetected = ((oneByte == 0x0a) && (prevByte == 0x0d)) ? true : false;\n        var newLineChar = ((oneByte == 0x0a) || (oneByte == 0x0d)) ? true : false;\n\n        if (!newLineChar)\n            lastline += String.fromCharCode(oneByte);\n\n        if ((0 == state) && newLineDetected) {\n            if ((\"--\" + boundary) == lastline) {\n                state = 1;\n            }\n            lastline = '';\n        } else\n            if ((1 == state) && newLineDetected) {\n                header = lastline;\n                state = 2;\n                lastline = '';\n            } else\n                if ((2 == state) && newLineDetected) {\n                    info = lastline;\n                    state = 3;\n                    lastline = '';\n                } else\n                    if ((3 == state) && newLineDetected) {\n                        state = 4;\n                        buffer = [];\n                        lastline = '';\n                    } else\n                        if (4 == state) {\n                            if (lastline.length > (boundary.length + 4)) lastline = ''; // mem save\n                            if ((((\"--\" + boundary) == lastline))) {\n                                var j = buffer.length - lastline.length;\n                                var part = buffer.slice(0, j - 1);\n                                var p = { header: header, info: info, part: part };\n                                allParts.push(process1(p));\n                                buffer = []; lastline = ''; state = 5; header = ''; info = '';\n                            } else {\n                                buffer.push(oneByte);\n                            }\n                            if (newLineDetected) lastline = '';\n                        } else\n                            if (5 == state) {\n                                if (newLineDetected)\n                                    state = 1;\n                            }\n    }\n    return allParts;\n};\n\nconst body = msg.payload;\nconst lines = body.toString().split('\\r\\n');\nconst boundary = lines[0].slice(2);\n\nconst parts = Parse(body, boundary);\n\n//msg.payload = parts;\nmsg.payload = parts[0].data;\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":200,"y":80,"wires":[[]]},{"id":"d265ab2822aac9ca","type":"subflow:e083faffd5cc2f5f","z":"e459b0abf68836a4","name":"","x":360,"y":500,"wires":[["b56e4a747df0ae93","17dfb474cbbab32a"]]}]